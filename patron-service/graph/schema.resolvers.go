package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"

	"github.com/GSalise/lms/patron-service/auth"
	"github.com/GSalise/lms/patron-service/graph/model"
)

// CreatePatron is the resolver for the createPatron field.
func (r *mutationResolver) CreatePatron(ctx context.Context, firstName string, lastName string, phoneNumber string, email string, password string) (*model.Patron, error) {
	var patron model.Patron

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	patron_id, PatronIDerr := auth.CreateSupabaseAuthUser(email, password)
	if PatronIDerr != nil {
		log.Printf("Failed to create an authenticated user: %v", PatronIDerr)
	}

	PatronErr := tx.QueryRow(ctx, `
		INSERT INTO patrons (patron_id, first_name, last_name, phone_number)
		VALUES ($1,$2,$3,$4)
		RETURNING patron_id, first_name, last_name, phone_number, patron_created::text
	`, patron_id, firstName, lastName, phoneNumber).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if PatronErr != nil {
		return nil, fmt.Errorf("failed to insert patron: %v", PatronErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	patronCopy := patron

	r.SubscribersMutex.Lock()
	for subscriber := range r.PatronSubscribers {
		select {
		case subscriber <- &patronCopy:
			// No action needed
		default:
			log.Printf("Subscriber channel full, skipping notification for patron %s", patron.PatronID)
		}
	}
	r.SubscribersMutex.Unlock()

	return &patron, nil
}

// UpdatePatron is the resolver for the updatePatron field.
func (r *mutationResolver) UpdatePatron(ctx context.Context, patronID string, firstName *string, lastName *string, phoneNumber *string) (*model.Patron, error) {
	var patron model.Patron

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	var exists bool
	err := tx.QueryRow(ctx, `
        SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
    `, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	if firstName != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET first_name = $1
			WHERE patron_id = $2
		`, firstName, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating first_name: %v", InsertErr)
		}
	}

	if lastName != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET last_name = $1
			WHERE patron_id = $2
		`, lastName, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating last_name: %v", InsertErr)
		}
	}

	// Note: add a condition that will only allow the correct regex for phone_number

	if phoneNumber != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET phone_number = $1
			WHERE patron_id = $2
		`, phoneNumber, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating phone_number: %v", InsertErr)
		}
	}

	FinalErr := tx.QueryRow(ctx, `
		SELECT patron_id, first_name, last_name, phone_number, patron_created::text
		FROM patrons
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if FinalErr != nil {
		return nil, fmt.Errorf("failed to update patron: %v", FinalErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &patron, nil
}

// DeletePatronByID is the resolver for the deletePatronById field.
func (r *mutationResolver) DeletePatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	var patron model.Patron

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	err := tx.QueryRow(ctx, `
        SELECT patron_id, first_name, last_name, phone_number, patron_created::text
        FROM patrons 
        WHERE patron_id = $1
    `, patronID).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("patron not found")
		}
		return nil, fmt.Errorf("failed to fetch patron: %v", err)
	}

	_, DeleteErr := tx.Exec(ctx, `
		DELETE from patrons
		WHERE patron_id = $1
	`, patronID)

	if DeleteErr != nil {
		return nil, fmt.Errorf("deletion failed: %v", DeleteErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	if authenticatedErr := auth.DeleteAuthenticatedUser(patronID); authenticatedErr != nil {
		log.Printf("warning: user deleted from DB, but failed to delete from Supabase Auth: %v", err)
	}

	return &patron, nil
}

// GetPatronByID is the resolver for the getPatronById field.
func (r *queryResolver) GetPatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	var patron model.Patron

	err := r.DB.QueryRow(ctx, `
		SELECT first_name, last_name, phone_number, patron_created::text
		FROM patrons
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if err != nil {
		return nil, fmt.Errorf("patron does not exist: %v", err)
	} else {
		patron.PatronID = patronID
	}

	return &patron, nil
}

// GetAllPatrons is the resolver for the getAllPatrons field.
func (r *queryResolver) GetAllPatrons(ctx context.Context) ([]*model.Patron, error) {
	var patrons []*model.Patron

	rows, err := r.DB.Query(ctx, `
		SELECT patron_id, first_name, last_name, phone_number, patron_created::text
		FROM patrons
	`)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch patrons: %v", err)
	}

	defer rows.Close()

	for rows.Next() {
		var patron model.Patron

		err := rows.Scan(
			&patron.PatronID,
			&patron.FirstName,
			&patron.LastName,
			&patron.PhoneNumber,
			&patron.PatronCreated,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan patron: %v", err)
		}

		patrons = append(patrons, &patron)

	}

	return patrons, nil
}

// PatronCreated is the resolver for the patronCreated field.
func (r *subscriptionResolver) PatronCreated(ctx context.Context) (<-chan *model.Patron, error) {
	patronChan := make(chan *model.Patron, 1)

	r.SubscribersMutex.Lock()
	r.PatronSubscribers[patronChan] = true
	r.SubscribersMutex.Unlock()

	go func() {
		<-ctx.Done()
		r.SubscribersMutex.Lock()
		delete(r.PatronSubscribers, patronChan)
		close(patronChan)
		r.SubscribersMutex.Unlock()
	}()

	return patronChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
