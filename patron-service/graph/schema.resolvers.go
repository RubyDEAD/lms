package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"

	"github.com/GSalise/lms/patron-service/auth"
	"github.com/GSalise/lms/patron-service/graph/model"
)

// CreatePatron is the resolver for the createPatron field.
func (r *mutationResolver) CreatePatron(ctx context.Context, firstName string, lastName string, phoneNumber string, email string, password string) (*model.Patron, error) {
	var patron model.Patron
	var patron_status model.PatronStatus

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	patron_id, PatronIDerr := auth.CreateSupabaseAuthUser(email, password)
	if PatronIDerr != nil {
		log.Printf("Failed to create an authenticated user: %v", PatronIDerr)
	}

	PatronErr := tx.QueryRow(ctx, `
		INSERT INTO patrons (patron_id, first_name, last_name, phone_number)
		VALUES ($1,$2,$3,$4)
		RETURNING patron_id, first_name, last_name, phone_number, patron_created::text
	`, patron_id, firstName, lastName, phoneNumber).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if PatronErr != nil {
		return nil, fmt.Errorf("failed to insert patron: %v", PatronErr)
	}

	PStatusErr := tx.QueryRow(ctx, `
		INSERT INTO patron_status (patron_id)
		VALUES($1)
		RETURNING warning_count, patron_status, unpaid_fees 
	`, patron.PatronID).Scan(
		&patron_status.WarningCount,
		&patron_status.PatronStatus,
		&patron_status.UnpaidFees,
	)

	if PStatusErr != nil {
		return nil, fmt.Errorf("failed to insert patron_status: %v", PStatusErr)
	}

	patron.Status = &patron_status
	patron_status.PatronID = patron.PatronID

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	patronCopy := patron

	r.SubscribersMutex.Lock()
	for subscriber := range r.PatronSubscribers {
		select {
		case subscriber <- &patronCopy:
			// No action needed
		default:
			log.Printf("Subscriber channel full, skipping notification for patron %s", patron.PatronID)
		}
	}
	r.SubscribersMutex.Unlock()

	return &patron, nil
}

// UpdatePatron is the resolver for the updatePatron field.
func (r *mutationResolver) UpdatePatron(ctx context.Context, patronID string, firstName *string, lastName *string, phoneNumber *string) (*model.Patron, error) {
	var patron model.Patron
	var patron_status model.PatronStatus

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	var exists bool
	err := tx.QueryRow(ctx, `
        SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
    `, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	if firstName != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET first_name = $1
			WHERE patron_id = $2
		`, firstName, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating first_name: %v", InsertErr)
		}
	}

	if lastName != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET last_name = $1
			WHERE patron_id = $2
		`, lastName, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating last_name: %v", InsertErr)
		}
	}

	// Note: add a condition that will only allow the correct regex for phone_number

	if phoneNumber != nil {
		_, InsertErr := tx.Exec(ctx, `
			UPDATE patrons
			SET phone_number = $1
			WHERE patron_id = $2
		`, phoneNumber, patronID)

		if InsertErr != nil {
			return nil, fmt.Errorf("error updating phone_number: %v", InsertErr)
		}
	}

	FinalErr := tx.QueryRow(ctx, `
		SELECT patron_id, first_name, last_name, phone_number, patron_created::text
		FROM patrons
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if FinalErr != nil {
		return nil, fmt.Errorf("failed to update patron: %v", FinalErr)
	} else {
		PStatusErr := tx.QueryRow(ctx, `
			SELECT warning_count, patron_status, unpaid_fees
			FROM patron_status
			WHERE patron_id = $1 
		`, patron.PatronID).Scan(
			&patron_status.WarningCount,
			&patron_status.PatronStatus,
			&patron_status.UnpaidFees,
		)

		if PStatusErr != nil {
			return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
		}

		patron.Status = &patron_status
		patron_status.PatronID = patron.PatronID

	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	return &patron, nil
}

// DeletePatronByID is the resolver for the deletePatronById field.
func (r *mutationResolver) DeletePatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	var patron model.Patron
	var patron_status model.PatronStatus

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	err := tx.QueryRow(ctx, `
        SELECT patron_id, first_name, last_name, phone_number, patron_created::text
        FROM patrons 
        WHERE patron_id = $1
    `, patronID).Scan(
		&patron.PatronID,
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("patron not found")
		}
		return nil, fmt.Errorf("failed to fetch patron: %v", err)
	} else {
		PStatusErr := tx.QueryRow(ctx, `
			SELECT warning_count, patron_status, unpaid_fees
			FROM patron_status
			WHERE patron_id = $1 
		`, patron.PatronID).Scan(
			&patron_status.WarningCount,
			&patron_status.PatronStatus,
			&patron_status.UnpaidFees,
		)

		if PStatusErr != nil {
			return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
		}

		patron.Status = &patron_status
		patron_status.PatronID = patron.PatronID

	}

	_, DeleteErr := tx.Exec(ctx, `
		DELETE from patrons
		WHERE patron_id = $1
	`, patronID)

	if DeleteErr != nil {
		return nil, fmt.Errorf("deletion failed: %v", DeleteErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	if authenticatedErr := auth.DeleteAuthenticatedUser(patronID); authenticatedErr != nil {
		log.Printf("warning: user deleted from DB, but failed to delete from Supabase Auth: %v", err)
	}

	return &patron, nil
}

// UpdatePatronStatus is the resolver for the updatePatronStatus field.
func (r *mutationResolver) UpdatePatronStatus(ctx context.Context, patronID string, warningCount *int32, unpaidFees *float64, patronStatus *model.Status) (*model.PatronStatus, error) {
	var exists bool
	err := r.DB.QueryRow(ctx, `
	    SELECT EXISTS(SELECT 1 FROM patrons WHERE patron_id = $1)
	`, patronID).Scan(&exists)

	if err != nil {
		return nil, fmt.Errorf("database error checking patron existence: %v", err)
	}
	if !exists {
		return nil, fmt.Errorf("patron does not exist")
	}

	var patron_status model.PatronStatus
	patron_status.PatronID = patronID

	tx, transactErr := r.DB.Begin(ctx)
	if transactErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", transactErr)
	}

	defer tx.Rollback(ctx)

	if warningCount != nil {
		_, StatusUpErr := tx.Exec(ctx, `
			UPDATE patron_status
			SET warning_count = $1
			WHERE patron_id = $2
		`, warningCount, patronID)

		if StatusUpErr != nil {
			return nil, fmt.Errorf("updating warning count failed: %v", StatusUpErr)
		}
	}

	if patronStatus != nil {
		_, StatusUpErr := tx.Exec(ctx, `
			UPDATE patron_status
			SET patron_status = $1
			WHERE patron_id = $2
		`, patronStatus, patronID)

		if StatusUpErr != nil {
			return nil, fmt.Errorf("updating patron_status failed: %v", StatusUpErr)
		}
	}

	if unpaidFees != nil {
		_, StatusUpErr := tx.Exec(ctx, `
			UPDATE patron_status
			SET unpaid_fees = $1
			WHERE patron_id = $2
		`, unpaidFees, patronID)

		if StatusUpErr != nil {
			return nil, fmt.Errorf("inserting warning count failed: %v", StatusUpErr)
		}
	}

	FinalErr := tx.QueryRow(ctx, `
		SELECT warning_count, patron_status, unpaid_fees
		FROM patron_status
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron_status.WarningCount,
		&patron_status.PatronStatus,
		&patron_status.UnpaidFees,
	)

	if FinalErr != nil {
		return nil, fmt.Errorf("fetching updated patron status failed: %v", FinalErr)
	}

	if transactErr := tx.Commit(ctx); transactErr != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", transactErr)
	}

	subscriptionCopy := patron_status

	r.SubscribersMutex.Lock()
	for subscriber := range r.UpdatesSubscrubers {
		select {
		case subscriber <- &subscriptionCopy:

		default:
			log.Printf("Subscriber channel full, skipping notification for patron %s", patron_status.PatronID)
		}
	}

	r.SubscribersMutex.Unlock()

	return &patron_status, nil
}

// GetPatronByID is the resolver for the getPatronById field.
func (r *queryResolver) GetPatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	var patron model.Patron
	var patron_status model.PatronStatus

	err := r.DB.QueryRow(ctx, `
		SELECT first_name, last_name, phone_number, patron_created::text
		FROM patrons
		WHERE patron_id = $1
	`, patronID).Scan(
		&patron.FirstName,
		&patron.LastName,
		&patron.PhoneNumber,
		&patron.PatronCreated,
	)

	if err != nil {
		return nil, fmt.Errorf("patron does not exist: %v", err)
	} else {
		patron.PatronID = patronID
	}

	PStatusErr := r.DB.QueryRow(ctx, `
		SELECT warning_count, patron_status, unpaid_fees
		FROM patron_status
		WHERE patron_id = $1 
	`, patron.PatronID).Scan(
		&patron_status.WarningCount,
		&patron_status.PatronStatus,
		&patron_status.UnpaidFees,
	)

	if PStatusErr != nil {
		return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
	}

	patron.Status = &patron_status
	patron_status.PatronID = patron.PatronID

	return &patron, nil
}

// GetAllPatrons is the resolver for the getAllPatrons field.
func (r *queryResolver) GetAllPatrons(ctx context.Context) ([]*model.Patron, error) {
	var patrons []*model.Patron

	rows, err := r.DB.Query(ctx, `
		SELECT patron_id, first_name, last_name, phone_number, patron_created::text
		FROM patrons
	`)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch patrons: %v", err)
	}

	defer rows.Close()

	for rows.Next() {
		var patron model.Patron
		var patron_status model.PatronStatus

		err := rows.Scan(
			&patron.PatronID,
			&patron.FirstName,
			&patron.LastName,
			&patron.PhoneNumber,
			&patron.PatronCreated,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan patron: %v", err)
		}

		PStatusErr := r.DB.QueryRow(ctx, `
			SELECT warning_count, patron_status, unpaid_fees
			FROM patron_status
			WHERE patron_id = $1 
		`, patron.PatronID).Scan(
			&patron_status.WarningCount,
			&patron_status.PatronStatus,
			&patron_status.UnpaidFees,
		)

		if PStatusErr != nil {
			return nil, fmt.Errorf("failed to fetch patron_status: %v", PStatusErr)
		}

		patron.Status = &patron_status
		patron_status.PatronID = patron.PatronID

		patrons = append(patrons, &patron)

	}

	return patrons, nil
}

// GetPatronStatusByType is the resolver for the getPatronStatusByType field.
func (r *queryResolver) GetPatronStatusByType(ctx context.Context, patronStatus model.Status) ([]*model.PatronStatus, error) {
	var patron_statuses []*model.PatronStatus

	statusRows, statusErr := r.DB.Query(ctx, `
		SELECT patron_id, warning_count, unpaid_fees
		FROM patron_status
		WHERE patron_status = $1
	`, patronStatus)

	if statusErr != nil {
		return nil, fmt.Errorf("failed to fetch patron_status_list: %v", statusErr)
	}

	defer statusRows.Close()

	for statusRows.Next() {
		var patron_status model.PatronStatus
		err := statusRows.Scan(
			&patron_status.PatronID,
			&patron_status.WarningCount,
			&patron_status.UnpaidFees,
		)

		if err != nil {
			return nil, fmt.Errorf("failed to scan patron status: %v", err)
		}

		patron_status.PatronStatus = patronStatus
		patron_statuses = append(patron_statuses, &patron_status)
	}

	return patron_statuses, nil
}

// PatronCreated is the resolver for the patronCreated field.
func (r *subscriptionResolver) PatronCreated(ctx context.Context) (<-chan *model.Patron, error) {
	patronChan := make(chan *model.Patron, 1)

	r.SubscribersMutex.Lock()
	r.PatronSubscribers[patronChan] = true
	r.SubscribersMutex.Unlock()

	go func() {
		<-ctx.Done()
		r.SubscribersMutex.Lock()
		delete(r.PatronSubscribers, patronChan)
		close(patronChan)
		r.SubscribersMutex.Unlock()
	}()

	return patronChan, nil
}

// PatronStatusUpdated is the resolver for the patronStatusUpdated field.
func (r *subscriptionResolver) PatronStatusUpdated(ctx context.Context) (<-chan *model.PatronStatus, error) {
	updatesChan := make(chan *model.PatronStatus, 1)

	r.SubscribersMutex.Lock()
	r.UpdatesSubscrubers[updatesChan] = true
	r.SubscribersMutex.Unlock()

	go func() {
		<-ctx.Done()
		r.SubscribersMutex.Lock()
		delete(r.UpdatesSubscrubers, updatesChan)
		close(updatesChan)
		r.SubscribersMutex.Unlock()
	}()

	return updatesChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
