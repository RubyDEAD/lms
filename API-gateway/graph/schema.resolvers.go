package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/Cat6utpcableclarke/API-gateway/graph/model"
	amqp "github.com/rabbitmq/amqp091-go"
)

// AddBook is the resolver for the addBook field.
func (r *mutationResolver) AddBook(ctx context.Context, title string, authorName string, datePublished string, description string, image *string) (*model.Book, error) {
	var img string = "image"
	if image != nil {
		img = *image
	}
	query := `
        mutation AddBook($title: String!, $author_name: String!, $datePublished: String!, $description: String!, $image: String) {
            addBook(title: $title, author_name: $author_name, datePublished: $datePublished, description: $description,image:$image) {
                id
                title
                author_name
                date_published
                description
				image
            }
        }
    `

	variables := map[string]interface{}{
		"title":         title,
		"author_name":   authorName,
		"datePublished": datePublished,
		"description":   description,
		"image":         img,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			AddBook *model.Book `json:"addBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.AddBook, nil
}

// AddBCopy is the resolver for the addBCopy field.
func (r *mutationResolver) AddBCopy(ctx context.Context, bookID string) (*model.BookCopies, error) {
	query := `
        mutation AddBCopy($bookID: String!) {
            addBCopy(bookID: $bookID) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"bookID": bookID,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			AddBCopy *model.BookCopies `json:"addBCopy"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.AddBCopy, nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, title string, authorName *string, datePublished *string, description *string) (*model.Book, error) {
	query := `
        mutation UpdateBook($id: String!, $title: String!, $author_name: String, $datePublished: String, $description: String) {
            updateBook(id: $id, title: $title, author_name: $author_name, datePublished: $datePublished, description: $description) {
                id
                title
                author_name
                date_published
                description
            }
        }
    `

	variables := map[string]interface{}{
		"id":            id,
		"title":         title,
		"author_name":   authorName,
		"datePublished": datePublished,
		"description":   description,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			UpdateBook *model.Book `json:"updateBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.UpdateBook, nil
}

// UpdateBookCopyStatus is the resolver for the updateBookCopyStatus field.
func (r *mutationResolver) UpdateBookCopyStatus(ctx context.Context, id string, bookStatus *string) (*model.BookCopies, error) {
	query := `
        mutation UpdateBookCopyStatus($id: ID!, $bookStatus: String) {
            updateBookCopyStatus(id: $id, book_status: $bookStatus) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id":         id,
		"bookStatus": bookStatus,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			UpdateBookCopyStatus *model.BookCopies `json:"updateBookCopyStatus"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.UpdateBookCopyStatus, nil
}

// DeleteBCopy is the resolver for the deleteBCopy field.
func (r *mutationResolver) DeleteBCopy(ctx context.Context, id string) (bool, error) {
	query := `
        mutation DeleteBCopy($id: String!) {
            deleteBCopy(id: $id)
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return false, err
	}

	var result struct {
		Data struct {
			DeleteBCopy bool `json:"deleteBCopy"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.DeleteBCopy, nil
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	query := `
        mutation DeleteBook($id: String!) {
            deleteBook(id: $id)
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return false, err
	}

	var result struct {
		Data struct {
			DeleteBook bool `json:"deleteBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.DeleteBook, nil
}

// CreatePatron is the resolver for the createPatron field.
func (r *mutationResolver) CreatePatron(ctx context.Context, firstName string, lastName string, phoneNumber string, email string, password string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"firstName":   firstName,
		"lastName":    lastName,
		"phoneNumber": phoneNumber,
		"email":       email,
		"password":    password,
	}

	//resp, err := forwardRequest(ctx, query, variables, patronServiceURL)
	resp, err := forwardRequestMQ(patronServiceQueue, variables, "createPatron")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			CreatePatron *model.Patron `json:"createPatron"`
		} `json:"data"`
	}
	// log.Printf("in createpatron: %s", resp)
	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	// log.Printf("check unmarshal: %+v", result.Data.CreatePatron)

	return result.Data.CreatePatron, nil
}

// UpdatePatron is the resolver for the updatePatron field.
func (r *mutationResolver) UpdatePatron(ctx context.Context, patronID string, firstName *string, lastName *string, phoneNumber *string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"patron_id":   patronID,
		"firstName":   firstName,
		"lastName":    lastName,
		"phoneNumber": phoneNumber,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updatePatron")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdatePatron *model.Patron `json:"updatePatron"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.UpdatePatron, nil
}

// DeletePatronByID is the resolver for the deletePatronById field.
func (r *mutationResolver) DeletePatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "deletePatronById")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			DeletePatronByID *model.Patron `json:"deletePatronById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.DeletePatronByID, nil
}

// UpdatePatronStatus is the resolver for the updatePatronStatus field.
func (r *mutationResolver) UpdatePatronStatus(ctx context.Context, patronID string, warningCount *int32, unpaidFees *float64, patronStatus *model.Status) (*model.PatronStatus, error) {
	variables := map[string]interface{}{
		"patron_id":     patronID,
		"warning_count": warningCount,
		"unpaid_fees":   unpaidFees,
		"status":        patronStatus,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updatePatronStatus")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdatePatronStatus *model.PatronStatus `json:"updatePatronStatus"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.UpdatePatronStatus, nil
}

// BorrowBook is the resolver for the borrowBook field.
func (r *mutationResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	query := `
	mutation BorrowBook($bookId: ID!, $patronId: ID!) {
		borrowBook(bookId: $bookId, patronId: $patronId) {
			id
			bookId
			patronId
			borrowedAt
			dueDate
			returnedAt
			renewalCount
			previousDueDate
			status
			bookCopyId
		}
	}
`

	variables := map[string]interface{}{
		"bookId":   bookID,
		"patronId": patronID,
	}

	// Assuming you have a lendingServiceURL constant defined
	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			BorrowBook *model.BorrowRecord `json:"borrowBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.BorrowBook, nil
}

// ReturnBook is the resolver for the returnBook field.
func (r *mutationResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	query := `
	mutation ReturnBook($recordId: ID!) {
		returnBook(recordId: $recordId) {
			id
			bookId
			patronId
			borrowedAt
			dueDate
			returnedAt
			renewalCount
			previousDueDate
			status
			bookCopyId
		}
	}
`

	variables := map[string]interface{}{
		"recordId": recordID,
	}

	// Assuming you have a lendingServiceURL constant defined
	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			ReturnBook *model.BorrowRecord `json:"returnBook"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.ReturnBook, nil
}

// RenewLoan is the resolver for the renewLoan field.
func (r *mutationResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	query := `
    mutation RenewLoan($recordId: ID!) {
        renewLoan(recordId: $recordId) {
            __typename
            ... on RenewalError {
                code
                message
            }
            ... on BorrowRecord {
                id
                bookId
                patronId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                bookCopyId
            }
        }
    }`

	variables := map[string]interface{}{
		"recordId": recordID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to renew loan: %v", err)
	}

	var result struct {
		Data struct {
			RenewLoan model.RenewLoanResult `json:"renewLoan"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse renewal response: %v", err)
	}

	return result.Data.RenewLoan, nil
}

// ReserveBook is the resolver for the reserveBook field.
func (r *mutationResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	query := `
    mutation ReserveBook($bookId: ID!, $patronId: ID!) {
        reserveBook(bookId: $bookId, patronId: $patronId) {
            id
            bookId
            patronId
            reservedAt
            status
            expiresAt
        }
    }`

	variables := map[string]interface{}{
		"bookId":   bookID,
		"patronId": patronID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		// Handle specific error cases
		if strings.Contains(err.Error(), "BOOK_NOT_AVAILABLE") {
			return nil, fmt.Errorf("this book is currently not available for reservation")
		}
		if strings.Contains(err.Error(), "PATRON_LIMIT_REACHED") {
			return nil, fmt.Errorf("patron has reached maximum allowed reservations")
		}
		return nil, fmt.Errorf("reservation failed: %v", err)
	}

	var result struct {
		Data struct {
			ReserveBook *model.Reservation `json:"reserveBook"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf(result.Errors[0].Message)
	}

	return result.Data.ReserveBook, nil
}

// CancelReservation is the resolver for the cancelReservation field.
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	query := `
    mutation CancelReservation($id: ID!) {
        cancelReservation(id: $id)
    }`

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return false, fmt.Errorf("failed to cancel reservation: %v", err)
	}

	var result struct {
		Data struct {
			CancelReservation bool `json:"cancelReservation"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to parse cancellation response: %v", err)
	}

	return result.Data.CancelReservation, nil
}

// FulfillReservation is the resolver for the fulfillReservation field.
// FulfillReservation is the resolver for the fulfillReservation field.
func (r *mutationResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
	query := `
        mutation FulfillReservation($id: ID!) {
            fulfillReservation(id: $id) {
                id
                bookId
                patronId
                bookCopyId
                reservedAt
                expiresAt
                status
            }
        }`

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fulfill reservation: %v", err)
	}

	// Parse the response
	var result struct {
		Data struct {
			FulfillReservation *model.Reservation `json:"fulfillReservation"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse fulfillment response: %v", err)
	}

	// Handle GraphQL errors
	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.FulfillReservation, nil
}

// CreateFine is the resolver for the createFine field.
func (r *mutationResolver) CreateFine(ctx context.Context, patronID string, bookID string, ratePerDay float64, violationType model.ViolationType, daysLate *int32) (*model.Fine, error) {
	query := `
        mutation CreateFine($patronID: String!, $bookID: String!, $ratePerDay: Float!, $violationType: ViolationType!, $daysLate: Int) {
            createFine(patronID: $patronID, bookID: $bookID, ratePerDay: $ratePerDay, violationType: $violationType, daysLate: $daysLate) {
                fine_id
                patron_id
                book_id
                days_late
                rate_per_day
                amount
                created_at
                violation_record_id
            }
        }`

	variables := map[string]interface{}{
		"patronID":      patronID,
		"bookID":        bookID,
		"ratePerDay":    ratePerDay,
		"violationType": violationType,
		"daysLate":      daysLate,
	}

	resp, err := forwardRequest(ctx, query, variables, fineServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to create fine: %v", err)
	}

	var result struct {
		Data struct {
			CreateFine *model.Fine `json:"createFine"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse fine creation response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.CreateFine, nil
}

// UpdateFine is the resolver for the updateFine field.
func (r *mutationResolver) UpdateFine(ctx context.Context, fineID string, daysLate int32, ratePerDay float64) (*model.Fine, error) {
	query := `
        mutation UpdateFine($fineID: String!, $daysLate: Int!, $ratePerDay: Float!) {
            updateFine(fineID: $fineID, daysLate: $daysLate, ratePerDay: $ratePerDay) {
                fine_id
                patron_id
                book_id
                days_late
                rate_per_day
                amount
                created_at
                violation_record_id
            }
        }`

	variables := map[string]interface{}{
		"fineID":     fineID,
		"daysLate":   daysLate,
		"ratePerDay": ratePerDay,
	}

	resp, err := forwardRequest(ctx, query, variables, fineServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to update fine: %v", err)
	}

	var result struct {
		Data struct {
			UpdateFine *model.Fine `json:"updateFine"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse update fine response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.UpdateFine, nil
}

// DeleteFine is the resolver for the deleteFine field.
func (r *mutationResolver) DeleteFine(ctx context.Context, fineID string) (bool, error) {
	query := `
        mutation DeleteFine($fineID: String!) {
            deleteFine(fineID: $fineID)
        }`

	variables := map[string]interface{}{
		"fineID": fineID,
	}

	resp, err := forwardRequest(ctx, query, variables, fineServiceURL)
	if err != nil {
		return false, fmt.Errorf("failed to delete fine: %v", err)
	}

	var result struct {
		Data struct {
			DeleteFine bool `json:"deleteFine"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return false, fmt.Errorf("failed to parse delete fine response: %v", err)
	}

	if len(result.Errors) > 0 {
		return false, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.DeleteFine, nil
}

// CreateViolationRecord is the resolver for the createViolationRecord field.
func (r *mutationResolver) CreateViolationRecord(ctx context.Context, patronID string, violationType model.ViolationType, violationInfo string) (*model.ViolationRecord, error) {
	query := `
        mutation CreateViolationRecord($patronID: String!, $violationType: ViolationType!, $violationInfo: String!) {
            createViolationRecord(patronID: $patronID, violationType: $violationType, violationInfo: $violationInfo) {
                violation_record_id
                patron_id
                violation_type
                violation_info
                violation_created
                violation_status
            }
        }`

	variables := map[string]interface{}{
		"patronID":      patronID,
		"violationType": violationType,
		"violationInfo": violationInfo,
	}

	resp, err := forwardRequest(ctx, query, variables, fineServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to create violation record: %v", err)
	}

	var result struct {
		Data struct {
			CreateViolationRecord *model.ViolationRecord `json:"createViolationRecord"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.CreateViolationRecord, nil
}

// UpdateViolationStatus is the resolver for the updateViolationStatus field.
func (r *mutationResolver) UpdateViolationStatus(ctx context.Context, violationRecordID string, violationStatus model.ViolationStatus) (*model.ViolationRecord, error) {
	query := `
        mutation UpdateViolationStatus($violationRecordID: String!, $violationStatus: ViolationStatus!) {
            updateViolationStatus(violationRecordID: $violationRecordID, violationStatus: $violationStatus) {
                violation_record_id
                patron_id
                violation_type
                violation_info
                violation_created
                violation_status
            }
        }`

	variables := map[string]interface{}{
		"violationRecordID": violationRecordID,
		"violationStatus":   violationStatus,
	}

	resp, err := forwardRequest(ctx, query, variables, fineServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to update violation status: %v", err)
	}

	var result struct {
		Data struct {
			UpdateViolationStatus *model.ViolationRecord `json:"updateViolationStatus"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.UpdateViolationStatus, nil
}

// DeleteViolationRecord is the resolver for the deleteViolationRecord field.
func (r *mutationResolver) DeleteViolationRecord(ctx context.Context, violationRecordID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteViolationRecord - deleteViolationRecord"))
}

// GetBooks is the resolver for the getBooks field.
func (r *queryResolver) GetBooks(ctx context.Context) ([]*model.Book, error) {
	query := `
        query {
            getBooks {
                id
                title
                author_name
                date_published
                description
				image
            }
        }
    `

	resp, err := forwardRequest(ctx, query, nil, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBooks []*model.Book `json:"getBooks"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBooks, nil
}

// GetBookByID is the resolver for the getBookById field.
func (r *queryResolver) GetBookByID(ctx context.Context, id string) (*model.Book, error) {
	query := `
        query GetBookById($id: String!) {
            getBookById(id: $id) {
                id
                title
                author_name
                date_published
                description
				image
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBookById *model.Book `json:"getBookById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBookById, nil
}

// GetBookCopiesByID is the resolver for the getBookCopiesById field.
func (r *queryResolver) GetBookCopiesByID(ctx context.Context, id string) ([]*model.BookCopies, error) {
	query := `
        query GetBookCopiesById($id: String!) {
            getBookCopiesById(id: $id) {
                id
                book_id
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			GetBookCopiesById []*model.BookCopies `json:"getBookCopiesById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetBookCopiesById, nil
}

// SearchBooks is the resolver for the searchBooks field.
func (r *queryResolver) SearchBooks(ctx context.Context, query string) ([]*model.Book, error) {
	searchQuery := `
        query SearchBooks($query: String!) {
            searchBooks(query: $query) {
                id
                title
                author_name
                date_published
                description
				image
            }
        }
    `

	variables := map[string]interface{}{
		"query": query,
	}

	resp, err := forwardRequest(ctx, searchQuery, variables, bookServiceURL)
	if err != nil {
		return nil, err
	}

	var result struct {
		Data struct {
			SearchBooks []*model.Book `json:"searchBooks"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.SearchBooks, nil
}

// GetAvailbleBookCopyByID is the resolver for the GetAvailbleBookCopyByID field.
func (r *queryResolver) GetAvailbleBookCopyByID(ctx context.Context, id string) (*model.BookCopies, error) {
	query := `
        query GetAvailbleBookCopyByID($id: String!) {
            getAvailbleBookCopyByID(id: $id) {
                id
                book_id
                title
                author_name
                date_published
                description
                book_status
            }
        }
    `

	variables := map[string]interface{}{
		"id": id,
	}

	// Forward the request to the Book Service
	resp, err := forwardRequest(ctx, query, variables, bookServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	// Parse the response
	var result struct {
		Data struct {
			GetAvailbleBookCopyByID *model.BookCopies `json:"getAvailbleBookCopyByID"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %v", err)
	}

	return result.Data.GetAvailbleBookCopyByID, nil
}

// GetPatronByID is the resolver for the getPatronById field.
func (r *queryResolver) GetPatronByID(ctx context.Context, patronID string) (*model.Patron, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getPatronById")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetPatronByID *model.Patron `json:"getPatronById"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetPatronByID, nil
}

// GetAllPatrons is the resolver for the getAllPatrons field.
func (r *queryResolver) GetAllPatrons(ctx context.Context) ([]*model.Patron, error) {
	variables := map[string]interface{}{}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getAllPatrons")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetAllPatrons []*model.Patron `json:"getAllPatrons"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetAllPatrons, nil
}

// GetPatronStatusByType is the resolver for the getPatronStatusByType field.
func (r *queryResolver) GetPatronStatusByType(ctx context.Context, patronStatus model.Status) ([]*model.PatronStatus, error) {
	variables := map[string]interface{}{
		"status": patronStatus,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getPatronStatusByType")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetPatronStatusByType []*model.PatronStatus `json:"getPatronStatusByType"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetPatronStatusByType, nil
}

// BorrowRecords is the resolver for the borrowRecords field.
func (r *queryResolver) BorrowRecords(ctx context.Context, patronID *string, bookID *string, status *model.BorrowStatus) ([]*model.BorrowRecord, error) {
	query := `
        query BorrowRecords($patronID: ID, $bookID: ID, $status: BorrowStatus) {
            borrowRecords(patronId: $patronID, bookId: $bookID, status: $status) {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	variables := map[string]interface{}{
		"patronID": patronID,
		"bookID":   bookID,
		"status":   status,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch borrow records: %v", err)
	}

	var result struct {
		Data struct {
			BorrowRecords []*model.BorrowRecord `json:"borrowRecords"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.BorrowRecords, nil
}

// Reservations is the resolver for the reservations field.
func (r *queryResolver) Reservations(ctx context.Context, patronID *string, bookID *string, status *model.ReservationStatus) ([]*model.Reservation, error) {
	query := `
        query Reservations($patronID: String, $bookID: String, $status: ReservationStatus) {
            reservations(patronID: $patronID, bookID: $bookID, status: $status) {
                id
                bookId
                patronId
                bookCopyId
                reservedAt
                expiresAt
                status
            }
        }`

	variables := map[string]interface{}{
		"patronID": patronID,
		"bookID":   bookID,
		"status":   status,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reservations: %v", err)
	}

	var result struct {
		Data struct {
			Reservations []*model.Reservation `json:"reservations"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.Reservations, nil
}

// OverdueRecords is the resolver for the overdueRecords field.
func (r *queryResolver) OverdueRecords(ctx context.Context) ([]*model.BorrowRecord, error) {
	query := `
        query {
            overdueRecords {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	resp, err := forwardRequest(ctx, query, nil, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch overdue records: %v", err)
	}

	var result struct {
		Data struct {
			OverdueRecords []*model.BorrowRecord `json:"overdueRecords"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.OverdueRecords, nil
}

// PatronBorrowHistory is the resolver for the patronBorrowHistory field.
func (r *queryResolver) PatronBorrowHistory(ctx context.Context, patronID string) ([]*model.BorrowRecord, error) {
	query := `
        query PatronBorrowHistory($patronId: ID!) {
            patronBorrowHistory(patronId: $patronId) {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	variables := map[string]interface{}{
		"patronId": patronID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch patron history: %v", err)
	}

	var result struct {
		Data struct {
			PatronBorrowHistory []*model.BorrowRecord `json:"patronBorrowHistory"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.PatronBorrowHistory, nil
}

// BorrowBook is the resolver for the borrowBook field.
func (r *queryResolver) BorrowBook(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	panic(fmt.Errorf("not implemented: BorrowBook - borrowBook"))
}

// ReturnBook is the resolver for the returnBook field.
func (r *queryResolver) ReturnBook(ctx context.Context, recordID string) (*model.BorrowRecord, error) {
	panic(fmt.Errorf("not implemented: ReturnBook - returnBook"))
}

// RenewLoan is the resolver for the renewLoan field.
func (r *queryResolver) RenewLoan(ctx context.Context, recordID string) (model.RenewLoanResult, error) {
	panic(fmt.Errorf("not implemented: RenewLoan - renewLoan"))
}

// ReserveBook is the resolver for the reserveBook field.
func (r *queryResolver) ReserveBook(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	panic(fmt.Errorf("not implemented: ReserveBook - reserveBook"))
}

// CancelReservation is the resolver for the cancelReservation field.
func (r *queryResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: CancelReservation - cancelReservation"))
}

// FulfillReservation is the resolver for the fulfillReservation field.
func (r *queryResolver) FulfillReservation(ctx context.Context, id string) (*model.Reservation, error) {
	panic(fmt.Errorf("not implemented: FulfillReservation - fulfillReservation"))
}

// CheckActiveBorrow is the resolver for the checkActiveBorrow field.
func (r *queryResolver) CheckActiveBorrow(ctx context.Context, bookID string, patronID string) (*model.BorrowRecord, error) {
	// Forward the request to the borrowing service
	query := `
        query CheckActiveBorrow($bookId: ID!, $patronId: ID!) {
            checkActiveBorrow(bookId: $bookId, patronId: $patronId) {
                id
                bookId
                patronId
                bookCopyId
                borrowedAt
                dueDate
                returnedAt
                renewalCount
                status
                previousDueDate
            }
        }`

	variables := map[string]interface{}{
		"bookId":   bookID,
		"patronId": patronID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to check active borrow: %v", err)
	}

	var result struct {
		Data struct {
			CheckActiveBorrow *model.BorrowRecord `json:"checkActiveBorrow"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.CheckActiveBorrow, nil
}

// CheckActiveReserve is the resolver for the checkActiveReserve field.
func (r *queryResolver) CheckActiveReserve(ctx context.Context, bookID string, patronID string) (*model.Reservation, error) {
	// Forward the request to the borrowing service
	query := `
        query CheckActiveReserve($bookId: ID!, $patronId: ID!) {
            checkActiveReserve(bookId: $bookId, patronId: $patronId) {
                id
                bookId
                patronId
                bookCopyId
                reservedAt
                expiresAt
                status
            }
        }`

	variables := map[string]interface{}{
		"bookId":   bookID,
		"patronId": patronID,
	}

	resp, err := forwardRequest(ctx, query, variables, borrowingServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to check active reserve: %v", err)
	}

	var result struct {
		Data struct {
			CheckActiveReserve *model.Reservation `json:"checkActiveReserve"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.CheckActiveReserve, nil
}

// GetFine is the resolver for the getFine field.
func (r *queryResolver) GetFine(ctx context.Context, fineID string) (*model.Fine, error) {
	query := `
        query GetFine($fineID: String!) {
            getFine(fineID: $fineID) {
                fine_id
                patron_id
                book_id
                days_late
                rate_per_day
                amount
                created_at
                violation_record_id
            }
        }
    `

	variables := map[string]interface{}{
		"fineID": fineID,
	}

	resp, err := forwardRequest(ctx, query, variables, fineServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to get fine: %v", err)
	}

	var result struct {
		Data struct {
			GetFine *model.Fine `json:"getFine"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse getFine response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.GetFine, nil
}

// ListFines is the resolver for the listFines field.
func (r *queryResolver) ListFines(ctx context.Context) ([]*model.Fine, error) {
	query := `
        query {
            listFines {
                fine_id
                patron_id
                book_id
                days_late
                rate_per_day
                amount
                created_at
                violation_record_id
            }
        }
    `

	resp, err := forwardRequest(ctx, query, nil, fineServiceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to list fines: %v", err)
	}

	var result struct {
		Data struct {
			ListFines []*model.Fine `json:"listFines"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse listFines response: %v", err)
	}

	if len(result.Errors) > 0 {
		return nil, fmt.Errorf("service error: %s", result.Errors[0].Message)
	}

	return result.Data.ListFines, nil
}

// GetViolationRecord is the resolver for the getViolationRecord field.
func (r *queryResolver) GetViolationRecord(ctx context.Context, violationRecordID string) (*model.ViolationRecord, error) {
	panic(fmt.Errorf("not implemented: GetViolationRecord - getViolationRecord"))
}

// ListViolationRecords is the resolver for the listViolationRecords field.
func (r *queryResolver) ListViolationRecords(ctx context.Context) ([]*model.ViolationRecord, error) {
	panic(fmt.Errorf("not implemented: ListViolationRecords - listViolationRecords"))
}

// BookAdded is the resolver for the bookAdded field.
func (r *subscriptionResolver) BookAdded(ctx context.Context) (<-chan *model.Book, error) {
	bookChan := make(chan *model.Book)
	err := SubscribeToBookAdded(ctx, bookChan)
	if err != nil {
		return nil, err
	}
	return bookChan, nil
}

// PatronCreated is the resolver for the patronCreated field.
func (r *subscriptionResolver) PatronCreated(ctx context.Context) (<-chan *model.Patron, error) {
	patronChan := make(chan *model.Patron)

	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		return nil, fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}

	ch, err := conn.Channel()
	if err != nil {
		conn.Close()
		return nil, fmt.Errorf("failed to open channel: %w", err)
	}

	_, err = ch.QueueDeclare(
		"patron-subscription-patronChan-queue",
		false,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to declare queue: %w", err)
	}

	msgs, err := ch.Consume(
		"patron-subscription-patronChan-queue",
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to consume: %w", err)
	}

	go func() {
		defer ch.Close()
		defer conn.Close()

		for {
			select {
			case <-ctx.Done():
				close(patronChan)
				return
			case msg := <-msgs:
				var response struct {
					Data struct {
						CreatePatron *model.Patron `json:"createPatron"`
					} `json:"data"`
				}

				if err := json.Unmarshal(msg.Body, &response); err == nil {
					patronChan <- response.Data.CreatePatron
				}
			}
		}
	}()

	return patronChan, nil
}

// PatronStatusUpdated is the resolver for the patronStatusUpdated field.
func (r *subscriptionResolver) PatronStatusUpdated(ctx context.Context) (<-chan *model.PatronStatus, error) {
	patronUpdatesChan := make(chan *model.PatronStatus)

	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		return nil, fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}

	ch, err := conn.Channel()
	if err != nil {
		conn.Close()
		return nil, fmt.Errorf("failed to open channel: %w", err)
	}

	_, err = ch.QueueDeclare(
		"patron-subscription-updatesChan-queue",
		false,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to declare queue: %w", err)
	}

	msgs, err := ch.Consume(
		"patron-subscription-updatesChan-queue",
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		ch.Close()
		conn.Close()
		return nil, fmt.Errorf("failed to consume: %w", err)
	}

	go func() {
		defer ch.Close()
		defer conn.Close()

		for {
			select {
			case <-ctx.Done():
				close(patronUpdatesChan)
				return
			case msg := <-msgs:
				var response struct {
					Data struct {
						PatronStatusUpdate *model.PatronStatus `json:"updatePatronStatus"`
					} `json:"data"`
				}

				if err := json.Unmarshal(msg.Body, &response); err == nil {
					patronUpdatesChan <- response.Data.PatronStatusUpdate
				}
			}
		}
	}()

	return patronUpdatesChan, nil
}

// ReservationCreated is the resolver for the reservationCreated field.
func (r *subscriptionResolver) ReservationCreated(ctx context.Context) (<-chan *model.Reservation, error) {
	panic(fmt.Errorf("not implemented: ReservationCreated - reservationCreated"))
}

// BorrowRecordUpdated is the resolver for the borrowRecordUpdated field.
func (r *subscriptionResolver) BorrowRecordUpdated(ctx context.Context) (<-chan *model.BorrowRecord, error) {
	panic(fmt.Errorf("not implemented: BorrowRecordUpdated - borrowRecordUpdated"))
}

// FineCreated is the resolver for the fineCreated field.
func (r *subscriptionResolver) FineCreated(ctx context.Context) (<-chan *model.Fine, error) {
	panic(fmt.Errorf("not implemented: FineCreated - fineCreated"))
	// out := make(chan *model.Fine, 1)

	// go func() {
	// 	defer close(out)

	// 	client := graphql.NewClient("http://localhost:8000/") // Replace with actual URL
	// 	req := graphql.NewRequest(`
	// 		subscription {
	// 			fineCreated {
	// 				fine_id
	// 				patronId
	// 				bookId
	// 				daysLate
	// 				ratePerDay
	// 				amount
	// 				createdAt
	// 				violationRecordId
	// 			}
	// 		}
	// 	`)

	// 	// Optional: Add headers for authentication if needed
	// 	// req.Header.Set("Authorization", "Bearer ...")

	// 	// This part requires a subscription-capable client, like graphql-ws
	// 	err := client.Run(ctx, req, func(respData map[string]interface{}) error {
	// 		data := respData["fineCreated"].(map[string]interface{})

	// 		out <- &model.Fine{
	// 			FineID:            data["fine_id"].(string),
	// 			PatronID:          data["patronId"].(string),
	// 			BookID:            data["bookId"].(string),
	// 			DaysLate:          int32(data["daysLate"].(float64)),
	// 			RatePerDay:        data["ratePerDay"].(float64),
	// 			Amount:            data["amount"].(float64),
	// 			CreatedAt:         data["createdAt"].(string),
	// 			ViolationRecordID: data["violationRecordId"].(string),
	// 		}

	// 		return nil
	// 	})

	// 	if err != nil {
	// 		// Handle connection/subscription failure
	// 		fmt.Println("Error subscribing to fineCreated:", err)
	// 	}
	// }()

	// return out, nil
}

// ViolationRecordCreated is the resolver for the violationRecordCreated field.
func (r *subscriptionResolver) ViolationRecordCreated(ctx context.Context) (<-chan *model.ViolationRecord, error) {
	panic(fmt.Errorf("not implemented: ViolationRecordCreated - violationRecordCreated"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) UpdateMembershipByPatronID(ctx context.Context, patronID string, level model.MembershipLevel) (*model.Membership, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
		"level":     level,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updateMembershipByPatronId")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdateMembershipByPatronID *model.Membership `json:"updateMembershipByPatronId"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.UpdateMembershipByPatronID, nil
}
func (r *mutationResolver) UpdateMembershipByMembershipID(ctx context.Context, membershipID string, level model.MembershipLevel) (*model.Membership, error) {
	variables := map[string]interface{}{
		"membership_id": membershipID,
		"level":         level,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "updateMembershipByMembershipId")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			UpdateMembershipByMembershipID *model.Membership `json:"updateMembershipByMembershipId"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.UpdateMembershipByMembershipID, nil
}
func (r *queryResolver) GetMembershipByLevel(ctx context.Context, level model.MembershipLevel) ([]*model.Membership, error) {
	variables := map[string]interface{}{
		"level": level,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getMembershipByLevel")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetMembershipByLevel []*model.Membership `json:"getMembershipByLevel"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetMembershipByLevel, nil
}
func (r *queryResolver) GetMembershipByPatronID(ctx context.Context, patronID string) (*model.Membership, error) {
	variables := map[string]interface{}{
		"patron_id": patronID,
	}

	resp, err := forwardRequestMQ(patronServiceQueue, variables, "getMembershipByPatronId")
	if err != nil {
		return nil, fmt.Errorf("failed to forward request: %v", err)
	}

	var result struct {
		Data struct {
			GetMembershipByPatronID *model.Membership `json:"getMembershipByPatronId"`
		} `json:"data"`
	}

	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshall response: %v", err)
	}

	return result.Data.GetMembershipByPatronID, nil
}
*/
