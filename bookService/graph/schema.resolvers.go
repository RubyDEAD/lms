package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/Cat6utpcableclarke/bookService/graph/model"
	"github.com/google/uuid"
)

// AddBook adds a new book along with the author (if the author does not exist).
func (r *mutationResolver) AddBook(ctx context.Context, title string, authorName string, datePublished string, description string, image *string) (*model.Book, error) {
	conn, err := r.DB.Acquire(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to acquire a database connection: %v", err)
	}
	defer conn.Release()

	// Begin a transaction
	tx, err := conn.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}

	// Ensure rollback in case of an error
	defer func() {
		if err != nil {
			tx.Rollback(ctx)
		}
	}()

	// Insert or get the author
	var authorID int
	err = tx.QueryRow(ctx, "INSERT INTO authors (author_name) VALUES ($1) ON CONFLICT (author_name) DO UPDATE SET author_name=EXCLUDED.author_name RETURNING id", authorName).Scan(&authorID)
	if err != nil {
		return nil, fmt.Errorf("failed to insert or get author: %v", err)
	}

	// Insert the book
	var bookID string
	var img string = ""
	if image != nil {
		img = *image
	}

	err = tx.QueryRow(ctx, "INSERT INTO books (title, author_id, date_published, description, image) VALUES ($1, $2, $3, $4, $5) RETURNING id", title, authorID, datePublished, description, img).Scan(&bookID)
	if err != nil {
		return nil, fmt.Errorf("failed to insert book: %v", err)
	}

	// Insert a book copy
	if bookID != "" {
		_, err = tx.Exec(ctx, "INSERT INTO book_copies (book_id) VALUES ($1)", bookID)
		if err != nil {
			return nil, fmt.Errorf("failed to insert book copy: %v", err)
		}
	}

	// Commit the transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	// Notify subscribers about the new book
	book := &model.Book{
		ID:            bookID,
		Title:         title,
		AuthorName:    authorName,
		DatePublished: datePublished,
		Description:   description,
		Image:         img,
	}
	r.mu.Lock()
	for key, observer := range r.BookAddedObservers {
		select {
		case observer <- book:
		default:
			// Clean up dead subscribers
			close(observer)
			delete(r.BookAddedObservers, key)
		}
	}
	r.mu.Unlock()

	return book, nil
}

// AddBCopy is the resolver for the addBCopy field.
func (r *mutationResolver) AddBCopy(ctx context.Context, bookID string) (*model.BookCopies, error) {
	conn, err := r.DB.Acquire(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to acquire a database connection: %v", err)
	}
	defer conn.Release()

	// Begin a transaction
	tx, err := conn.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}

	// Ensure rollback in case of an error
	defer func() {
		if err != nil {
			tx.Rollback(ctx)
		}
	}()

	// Insert a book copy
	_, err = tx.Exec(ctx, "INSERT INTO book_copies (book_id) VALUES ($1)", bookID)
	if err != nil {
		return nil, fmt.Errorf("failed to insert book copy: %v", err)
	}

	// Fetch the book copy details
	var copy model.BookCopies
	var datePublished time.Time
	query := `
        SELECT bc.id, bc.book_id, b.title, a.author_name, b.date_published, b.description, bc.book_status
        FROM book_copies AS bc
        JOIN books AS b ON bc.book_id = b.id
        JOIN authors AS a ON b.author_id = a.id
        WHERE bc.book_id = $1
    `
	err = tx.QueryRow(ctx, query, bookID).Scan(&copy.ID, &copy.BookID, &copy.Title, &copy.AuthorName, &datePublished, &copy.Description, &copy.BookStatus)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch book copy: %v", err)
	}

	// Commit the transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	// Convert `datePublished` to string
	copy.DatePublished = datePublished.Format("2006-01-02")
	return &copy, nil
}

// AddAuthor is the resolver for the addAuthor field.
func (r *mutationResolver) AddAuthor(ctx context.Context, authorName string) (*model.Author, error) {
	var authorID int
	query := `
        INSERT INTO authors (author_name) 
        VALUES ($1) 
        ON CONFLICT (author_name) 
        DO UPDATE SET author_name = EXCLUDED.author_name 
        RETURNING id
    `
	err := r.DB.QueryRow(ctx, query, authorName).Scan(&authorID)
	if err != nil {
		return nil, fmt.Errorf("failed to insert or update author: %w", err)
	}

	return &model.Author{
		ID:         int32(authorID),
		AuthorName: authorName,
	}, nil
}

// UpdateBook updates an existing book's details.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, title *string, authorName string, datePublished *string, description *string) (*model.Book, error) {
	// Begin a transaction
	conn, err := r.DB.Acquire(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to acquire a database connection: %v", err)
	}
	defer conn.Release()

	tx, err := r.DB.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}

	// Ensure rollback in case of an error
	defer func() {
		if err != nil {
			tx.Rollback(ctx)
		}
	}()

	// Insert or update the author
	var authorID int
	err = tx.QueryRow(ctx, "INSERT INTO authors (author_name) VALUES ($1) ON CONFLICT (author_name) DO UPDATE SET author_name=EXCLUDED.author_name RETURNING id", authorName).Scan(&authorID)
	if err != nil {
		return nil, fmt.Errorf("failed to insert or update author: %v", err)
	}

	// Update the book
	_, err = tx.Exec(ctx, "UPDATE books SET title=COALESCE($1, title), author_id=$2, date_published=COALESCE($3, date_published), description=COALESCE($4, description) WHERE id=$5", title, authorID, datePublished, description, id)
	if err != nil {
		return nil, fmt.Errorf("failed to update book: %v", err)
	}

	// Commit the transaction
	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	// Return the updated book
	return &model.Book{
		ID: id,
		Title: func() string {
			if title != nil {
				return *title
			}
			return ""
		}(),
		AuthorName: authorName,
		DatePublished: func() string {
			if datePublished != nil {
				return *datePublished
			}
			return ""
		}(),
		Description: func() string {
			if description != nil {
				return *description
			}
			return ""
		}(),
	}, nil
}

// UpdateBookCopyStatus updates the status of a book copy.
func (r *mutationResolver) UpdateBookCopyStatus(ctx context.Context, id string, bookStatus *string) (*model.BookCopies, error) {
	_, err := r.DB.Exec(ctx, "UPDATE book_copies SET book_status=$1 WHERE id=$2", bookStatus, id)
	if err != nil {
		return nil, fmt.Errorf("failed to update book copy status: %v", err)
	}

	return &model.BookCopies{
		ID: id,
		BookStatus: func() string {
			if bookStatus != nil {
				return *bookStatus
			}
			return ""
		}(),
	}, nil
}

// DeleteBook deletes a book by ID.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	_, err := r.DB.Exec(ctx, "DELETE FROM books WHERE id=$1", id)
	if err != nil {
		return false, fmt.Errorf("failed to delete book: %v", err)
	}
	return true, nil
}

// DeleteBCopy is the resolver for the deleteBCopy field.
func (r *mutationResolver) DeleteBCopy(ctx context.Context, id string) (bool, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid ID format: %v", err)
	}

	_, err = r.DB.Exec(ctx, "DELETE FROM book_copies WHERE id=$1", intID)
	if err != nil {
		return false, fmt.Errorf("failed to delete book copy: %v", err)
	}
	return true, nil
}

// DeleteAuthor is the resolver for the deleteAuthor field.
func (r *mutationResolver) DeleteAuthor(ctx context.Context, id string) (bool, error) {
	_, err := r.DB.Exec(ctx, "DELETE FROM authors WHERE id=$1", id)
	if err != nil {
		return false, fmt.Errorf("failed to delete author: %v", err)
	}
	return true, nil
}

// GetBooks is the resolver for the getBooks field.
func (r *queryResolver) GetBooks(ctx context.Context) ([]*model.Book, error) {
	conn, err := r.DB.Acquire(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to acquire a database connection: %v", err)
	}
	defer conn.Release()

	var books []*model.Book
	rows, err := r.DB.Query(ctx, "SELECT b.id, b.title, a.author_name, b.date_published, b.description , b.image FROM books b JOIN authors a ON b.author_id = a.id")
	if err != nil {
		return nil, fmt.Errorf("failed to fetch books: %v", err)
	}
	defer rows.Close()
	for rows.Next() {
		var book model.Book
		var authorName string
		var date_published time.Time // Store as time.Time to handle DATE type
		err := rows.Scan(&book.ID, &book.Title, &authorName, &date_published, &book.Description, &book.Image)
		if err != nil {
			return nil, fmt.Errorf("failed to scan book: %v", err)
		}
		// Convert `datePublished` to string (ISO 8601 format)
		formattedDate := date_published.Format("2006-01-02")
		book.DatePublished = formattedDate
		book.AuthorName = authorName
		books = append(books, &book)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate over books: %v", err)
	}
	return books, nil
}

// GetAuthor is the resolver for the getAuthor field.
func (r *queryResolver) GetAuthor(ctx context.Context) ([]*model.Author, error) {
	rows, err := r.DB.Query(ctx, "SELECT id, author_name FROM authors")
	if err != nil {
		return nil, fmt.Errorf("failed to fetch authors: %v", err)
	}
	defer rows.Close()
	var authors []*model.Author
	for rows.Next() {
		var author model.Author
		err := rows.Scan(&author.ID, &author.AuthorName)
		if err != nil {
			return nil, fmt.Errorf("failed to scan author: %v", err)
		}
		authors = append(authors, &author)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate over authors: %v", err)
	}
	return authors, nil
}

// GetBookCopies is the resolver for the getBookCopies field.
func (r *queryResolver) GetBookCopies(ctx context.Context) ([]*model.BookCopies, error) {
	rows, err := r.DB.Query(ctx, `SELECT 
        bc.id, 
        bc.book_id, 
        b.title, 
        a.author_name, 
        b.date_published, 
        b.description, 
        bc.book_status 
    FROM book_copies AS bc 
    JOIN books AS b ON bc.book_id = b.id 
    JOIN authors AS a ON b.author_id = a.id`)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch book copies: %v", err)
	}
	defer rows.Close()

	var copies []*model.BookCopies
	for rows.Next() {
		var copy model.BookCopies
		var datePublished time.Time // Use time.Time to handle DATE type

		err := rows.Scan(
			&copy.ID,
			&copy.BookID,
			&copy.Title,
			&copy.AuthorName,
			&datePublished,
			&copy.Description,
			&copy.BookStatus,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan book copy: %v", err)
		}

		// Convert `datePublished` to string (ISO 8601 format)
		copy.DatePublished = datePublished.Format("2006-01-02")
		copies = append(copies, &copy)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate over book copies: %v", err)
	}

	return copies, nil
}

// GetFilteredBooks fetches books based on filters.
func (r *queryResolver) GetFilteredBooks(ctx context.Context, filter *model.BookFilter) ([]*model.Book, error) {
	return nil, fmt.Errorf("not implemented: GetFilteredBooks")
}

// GetBookByID fetches a book by its ID.
func (r *queryResolver) GetBookByID(ctx context.Context, id string) (*model.Book, error) {
	var book model.Book
	var authorName string
	var datePublished time.Time // Store as time.Time to handle DATE type

	err := r.DB.QueryRow(ctx, "SELECT b.id, b.title, a.author_name, b.date_published, b.description, b.image FROM books b JOIN authors a ON b.author_id = a.id WHERE b.id=$1", id).
		Scan(&book.ID, &book.Title, &authorName, &datePublished, &book.Description, &book.Image)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch book: %v", err)
	}

	// Convert `datePublished` to string (ISO 8601 format)
	formattedDate := datePublished.Format("2006-01-02")
	book.DatePublished = formattedDate
	book.AuthorName = authorName

	return &book, nil
}

// GetBookCopiesByID fetches all copies of a book by book ID.
func (r *queryResolver) GetBookCopiesByID(ctx context.Context, id string) ([]*model.BookCopies, error) {
	// Query to fetch book copies by book ID
	query := `SELECT bc.id, bc.book_id, b.title, a.author_name, b.date_published,
	 b.description, bc.book_status FROM book_copies AS bc 
	 JOIN books AS b ON bc.book_id = b.id 
	 JOIN authors AS a ON b.author_id = a.id 
	 WHERE bc.book_id = $1`

	rows, err := r.DB.Query(ctx, query, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch book copies: %v", err)
	}
	defer rows.Close()

	var copies []*model.BookCopies
	for rows.Next() {
		var copy model.BookCopies
		var datePublished time.Time // Use time.Time to handle DATE type

		// Scan the row into the BookCopies model
		err := rows.Scan(
			&copy.ID,
			&copy.BookID,
			&copy.Title,
			&copy.AuthorName,
			&datePublished,
			&copy.Description,
			&copy.BookStatus,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan book copy: %v", err)
		}

		// Convert `datePublished` to string (ISO 8601 format)
		copy.DatePublished = datePublished.Format("2006-01-02")
		copies = append(copies, &copy)
	}

	// Check for errors during iteration
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate over book copies: %v", err)
	}

	return copies, nil
}

// SearchBooks allows searching books by title or author name.
func (r *queryResolver) SearchBooks(ctx context.Context, query string) ([]*model.Book, error) {
	rows, err := r.DB.Query(ctx, "SELECT b.id, b.title, a.author_name, b.date_published, b.description,b.image FROM books b JOIN authors a ON b.author_id = a.id WHERE b.title ILIKE $1 OR a.author_name ILIKE $1 OR b.description ILIKE $1", "%"+query+"%")
	if err != nil {
		return nil, fmt.Errorf("failed to search books: %v", err)
	}
	defer rows.Close()

	var books []*model.Book
	for rows.Next() {
		var book model.Book
		var authorName string
		var datePublished time.Time // Store as time.Time to handle DATE type

		// Scan the row into the Book model

		err := rows.Scan(&book.ID, &book.Title, &authorName, &datePublished, &book.Description, &book.Image)
		if err != nil {
			return nil, fmt.Errorf("failed to scan book: %v", err)
		}
		book.AuthorName = authorName
		book.DatePublished = datePublished.Format("2006-01-02") // Convert to string (ISO 8601 format)
		// Append the book to the slice
		books = append(books, &book)
	}
	return books, nil
}

// GetAvailbleBookCopyByID is the resolver for the getAvailbleBookCopyByID field.
func (r *queryResolver) GetAvailbleBookCopyByID(ctx context.Context, id string) (*model.BookCopies, error) {
	// Query to fetch available book copy by ID
	query := `SELECT bc.id, bc.book_id, b.title, a.author_name, b.date_published,
	 b.description, bc.book_status FROM book_copies AS bc 
	 JOIN books AS b ON bc.book_id = b.id 
	 JOIN authors AS a ON b.author_id = a.id 
	 WHERE bc.book_id = $1 AND book_status ='Available'
     ORDER BY id
     LIMIT 1`

	row := r.DB.QueryRow(ctx, query, id)
	var copy model.BookCopies
	var datePublished time.Time // Use time.Time to handle DATE type
	// Scan the row into the BookCopies model
	err := row.Scan(
		&copy.ID,
		&copy.BookID,
		&copy.Title,
		&copy.AuthorName,
		&datePublished,
		&copy.Description,
		&copy.BookStatus)
	if err != nil {
		return nil, fmt.Errorf("failed to scan book copy: %v", err)
	}
	// Convert `datePublished` to string (ISO 8601 format)
	copy.DatePublished = datePublished.Format("2006-01-02")
	return &copy, nil
}

// BookAdded is the resolver for the bookAdded field.
func (r *subscriptionResolver) BookAdded(ctx context.Context) (<-chan *model.Book, error) {
	id := uuid.NewString()
	events := make(chan *model.Book, 1) // Buffered to prevent blocking

	r.mu.Lock()
	r.BookAddedObservers[id] = events
	r.mu.Unlock()

	go func() {
		<-ctx.Done() // Remove observer when client disconnects
		r.mu.Lock()
		delete(r.BookAddedObservers, id)
		r.mu.Unlock()
	}()

	return events, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
